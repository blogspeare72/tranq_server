#TODO tidy this code
#TODO at least one line comment of what method does
#TODO fix indentation
#TODO pass flags as options

module ApiMetadataHelper
  
  # these constants reflect special values found in the api metadata file AND values used when constructing the augmented metadata (as rules run)  
  # this avoids having strings in any of the framework or rule code (where possible)
  # the general format of these constants is PROPERTY__VALUE. Thus CHECKING_STATUS__RESOLVED is the value "resolved" for the property checking status

  # standard_checks_required is object property under each context / version / resource.
  # It is generated by tranquilize - its not something the api owner enters
  # it used to list the standards we will need to check for the object in question. Example
  # constants relating to standards_checks_required
  STANDARD_CHECKS_REQUIRED ="standard_checks_required"
  ID = "id"
  VIOLATION_COUNT ="violation_count"
  CHECKING_STATUS = "checking_status"
  CHECKING_STATUS__RESOLVED = "resolved"
  CHECKING_STATUS__UNRESOLVED = "unresolved"
  VALID_CHECKING_STATUS = [CHECKING_STATUS__RESOLVED,CHECKING_STATUS__UNRESOLVED]
  COMPLIANT = "compliant"
  COMPLIANT__Y = "Y"
  COMPLIANT__N = "N"
  VALID_COMPLIANT = [COMPLIANT__Y,COMPLIANT__N]
  COMPLIANT__UNKNOWN = "?"
  HOW_RESOLVED = "how_resolved"
  HOW_RESOLVED__SUPPORTED ="supported"
  HOW_RESOLVED__UNSUPPORTED = "unsupported"
  HOW_RESOLVED__STATED = "stated"
  HOW_RESOLVED__AUTOMATED = "automated"
  VALID_HOW_RESOLVED = [HOW_RESOLVED__SUPPORTED,HOW_RESOLVED__UNSUPPORTED,HOW_RESOLVED__STATED,HOW_RESOLVED__AUTOMATED]
  
  # triggering_standards  is an object property under each context / version / resource. 
  # The API owner enters the information in this section to indicate whether 
  # optional standards are supported on not. If a standard is supported it may trigger tranquilize to check other standards. Example
  # constants relating to supported_standards  
  
  TRIGGERING_STANDARDS = "triggering_standards"
  TRIGGERING_STANDARD__SUPPORTED = "supported"
  TRIGGERING_STANDARD__UNSUPPORTED = "unsupported"
  
  # constants relating to stating compliance  
  
  STATED = "stated_compliance"
  STATED__COMPLIANT = "compliant"
  STATED__UNCOMPLIANT = "uncompliant"
  
  META_CONTEXTS= "contexts"
  META_VERSIONS= "versions"
  META_RESOURCES = "resources"
  RESOURCE_TYPE__COLLECTION = "collection"
  RESOURCE_TYPE__SINGULAR = "singular"
  RESOURCE_PAGE_LINKS__HEADER = "header"
  RESOURCE_PAGE_LINKS__BODY = "body"
  #  RESOURCE_TYPE__RESOURCE = "resource"
 
  ###########################################################################################
  # the following methods are expected to be called from rule code and are therefore public #
  ###########################################################################################
public

  # sets the resolution status on an object to CHECKING_STATUS__RESOLVED and compliance to N for a given standard.
  # Also adds the violation to the violations array.
  # does so by calling a more general method after setting some additional values and checking to ensure the standard id is valid
  def self.resolve_standard_with_violation(object,violations,s_id,msg,how_resolved)
    StandardsHelper.get_standard_by_id(s_id)
    self.add_violation_plus_update_metadata(object,violations,s_id,msg,CHECKING_STATUS__RESOLVED,how_resolved,COMPLIANT__N)
  end

  # sets the resolution status on an object to CHECKING_STATUS__RESOLVED and compliance to Y for a given standard.
  # does so by calling a more general method after setting some additional values and checking to ensure the standard id is valid
  def self.resolve_standard_without_violation(standard_id,object,how_resolved)
    StandardsHelper.get_standard_by_id(standard_id)
    self.update_standard_checks_required(standard_id,object,CHECKING_STATUS__RESOLVED,how_resolved,COMPLIANT__Y)
  end 
  
  # sets the resolution status on an object for a list of standard IF no violations have been registered to that object as yet.
  # This method is particularly useful towards the end of a rule when we have executed all the necessary checks to find violations and now want to mark
  # as compliant. This can help avoid clutter due to branching if/then logic that would otherwise be needed in the rule
  def self.resolve_unresolved_standards_without_violation(standard_ids,object,how_resolved)
    standard_ids.each do |s_id|
      StandardsHelper.get_standard_by_id(s_id)
      ApiMetadataHelper.resolve_standard_without_violation(s_id,object,how_resolved) if (ApiMetadataHelper.get_checking_status(object,s_id) == CHECKING_STATUS__UNRESOLVED)
    end
  end

  ################################################################################
  # these methods should not be called from rule code and are therefore private  #
  ################################################################################
  private 
 
  def self.hierarchy(object)
    if(object['resource'])
      return "#{object['context']}(context) > #{object['version']}(version) > #{object['resource']}(resource)"
    end
    if(object['version'])
      return "#{object['version']}(version)"
    end
    if(object['context'])
      return "#{object['context']}(context)"
    end
   
    
  end 
 
  # gets the checking_status for a given metadata object (context, version or resource) 
  # also does a sanity check which is to make sure that the standard we want to know the status for is actually one we will be checking for the object in question
  def self.get_checking_status(object,s_id)
    matching_checks = (object["standard_checks_required"].select{ |check| check["id"]==s_id})
    OutputHelper.fatal_msg("Trying to access the checking status of #{s_id} even though this was not established as a standard to check against the resource #{object}") if matching_checks.size !=1
    return matching_checks[0]["checking_status"]
  end

  def self.has_required_check(object,s_id)
    matching_checks = (object["standard_checks_required"].select{ |check| check["id"]==s_id})
    return (matching_checks.size ==1 ? true : false) 
  end  
  
  # adds violation to violation array and also updates the standard_checks_required sections for a given standard  
  def self.add_violation_plus_update_metadata(resource,violations,s_id,msg,checking_status,how_resolved,compliant)
    StandardsHelper.get_standard_by_id(s_id)
    ViolationHelper.add_violation(resource,violations,s_id,msg)
    ApiMetadataHelper.update_standard_checks_required(s_id,resource,checking_status,how_resolved,compliant)
  end  

  # updates the entry under standard_checks_rquired after checking the update values are valid
  # Example entry - found directly under the object in question
  def self.update_standard_checks_required(standard_id,object,checking_status,how_resolved,compliant)
 
    OutputHelper.fatal_msg("invalid value (#{checking_status}) for checking_statusproperty") if !VALID_CHECKING_STATUS.include? (checking_status)
    # may need to account for 'stated and helper'
    OutputHelper.fatal_msg("invalid value (#{how_resolved}) for how_resolved  property") if  ! VALID_HOW_RESOLVED.include?(how_resolved)
    OutputHelper.fatal_msg("invalid value (#{compliant}) for compliant  property") if !VALID_COMPLIANT.include?(compliant)
    puts object
    object[STANDARD_CHECKS_REQUIRED].select{|scr| scr["id"]==standard_id}.each do |scr|
      scr[CHECKING_STATUS]=checking_status
      scr[HOW_RESOLVED]=how_resolved
      scr[COMPLIANT]=compliant 
    end

  end

  public

  #adds a "standard_check_required" to metadata, initilizing values to unresolved. Creates standard_checks_required property if doesnt already exist

  def self.add_standard_check_required(object,standard)
    
    if (!object[STANDARD_CHECKS_REQUIRED]) then
      object[STANDARD_CHECKS_REQUIRED] = []
    end
    standard_check_required = Hash.new();
    standard_check_required[CHECKING_STATUS]=CHECKING_STATUS__UNRESOLVED
    standard_check_required[ID]=standard["id"]
    standard_check_required[HOW_RESOLVED]=nil
    standard_check_required[COMPLIANT]=nil
    standard_check_required[VIOLATION_COUNT]=0
    object[STANDARD_CHECKS_REQUIRED]<<standard_check_required
    
  end

  # checks to see if, for a given dependent standard, that the triggering standard it depends on is supported for a given object. This is used in determining if the dependent standard must be checked in the run (or not)
  # concrete example: H002_RESOURCE_METADATA_URI depends on H001_PROVIDE_RESOURCE_METADATA.
  # Calling triggering_standards_supported_on_object passing in a version as the objet and H002_RESOURCE_METADATA_URI would return true IF the version had the following section under it
  def self.triggering_standard_supported_on_object(object,standard)
    for ts in object[TRIGGERING_STANDARDS]
      supported = ts['value'] if (ts['id']==standard['dependency_on'])
    end 
    return true  if ( supported == TRIGGERING_STANDARD__SUPPORTED)   
  end
  
  # this method simplifies determining if a dependent standard should be checked when the triggering standard is not set at the same scope. 
  # For example, there may me a dependent standard that is verified at the resource level has a depedencing on a triggering_standard set at the 
  # context level
  def self.triggering_standard_supported_on_object_or_parent_objects(parents,object,standard)
    return true if self.triggering_standard_supported_on_object(object,standard)
    return true if (parents.select{ |cxt,obj| self.triggering_standard_supported_on_object(obj,standard)}).size > 0
  end  



  # where compliance is stated we resolve it before continuing with automated checks
  # we also carry out some validation to make sure what is being stated in the metadata file makes sense
  # 1. You should not be able state compliance for a standard the tranquilize can check in an automated fashion
  # 2. You should not be able to state compliance for a standard that doesnt require checking. For example, if your api does not support metadata you should not be able to resolve compliance. Thus we stop execution if we don't find an unresolved standard agains the object in question

  def self.account_for_stated_compliance(object,violations)
    OutputHelper.puts_opt("Accounting for Stated Compliance for #{self.hierarchy(object)}","debug")
    msg = "Stated as not compliant"
    if(object[STATED])
      puts "has stated"
# first do validation that the entry makes sense
      object[STATED].each do |stated|
        OutputHelper.puts_opt("Processing Stated Compliance for standard #{stated}","detail_debug")
        OutputHelper.fatal_msg("You are stating compliance for a standard that is verified by tranquilize") if StandardsHelper.get_standard_by_id(stated["id"])["tranquilize"]=="Automated"
        OutputHelper.fatal_msg("You are stating compliance for a standard (#{stated["id"]}) that does not required to be checked for #{hierarchy(object)}. Relevant standards are #{object[STANDARD_CHECKS_REQUIRED]}")        if !has_required_check(object,stated["id"]) 
        # now we know its a valid statement, resolve standard  
        case stated["value"]
        when STATED__COMPLIANT
          self.resolve_standard_without_violation(stated["id"],object,HOW_RESOLVED__STATED)
        when STATED__UNCOMPLIANT
          self.resolve_standard_with_violation(object,violations,stated["id"],msg,HOW_RESOLVED__STATED)
        else OutputHelper.fatal_msg("The value #{stated["value"]} is not valid!")  
        end                 


      end
    end
  end

  # adds the required standard checks to a given object in the metadata hierarchy
  # forecach standard that has a scope property that includes the scope of the object
  #   if the standards is a triggering standard we can immediatly resolve compliance because compliance MUST be stated for these types of standard
  #   if the standards is a depedendant standard only add the check if the triggering standard it depends on is supported. If it is add the standard check
  #   if the standard is neither depededent or triggering add a standard check
  def self.add_standards_checks_required(parents,object,standard_scope,standards,violations)
    OutputHelper.puts_opt("Adding StandardsHelper for #{hierarchy(object)}","debug")
    #puts "--starting adding standards checks scope #{standard_scope}"  
    for standard in standards
      #      puts standard['scopes'].inspect
      if standard['scopes'].include?(standard_scope) then
        OutputHelper.puts_opt("Standard #{standard["id"]} applies to this object","detail_debug")        
        if (standard['dependency']=="dependent") then 
          for ts in object["triggering_standards"]
            supported = ts['value'] if (ts['id']==standard['dependency_on'])
          end
          #          puts("Triggering standard #{standard['dependency_on']} is #{supported}")
          # in some cases the triggering standards can be set at different (higher) level than the level at which the dependent standards must be tested
          # hence we must also check up the hierarchy to see if its supported  
          if self.triggering_standard_supported_on_object_or_parent_objects(parents,object,standard)  then     
            #           puts "triggering standard support on object or parent" 
            #          if ( supported == 'supported')  then
            self.add_standard_check_required(object,standard) 
            
          end         
        else
          self.add_standard_check_required(object,standard)
          # if this is triggering standard - look for metadata saying if it is supported or not - and resolve compliance          
          if (standard['dependency']==StandardsHelper::DEPENDENCY__TRIGGERING )
            #          puts "Found triggering standard #{standard['id']} "  
            for ts in object["triggering_standards"]
              supported = ts['value'] if (ts['id']==standard['id'])
            end
            #          puts "this standard is #{supported}"    
            how_resolved =(  (supported == TRIGGERING_STANDARD__UNSUPPORTED) ? HOW_RESOLVED__UNSUPPORTED : HOW_RESOLVED__SUPPORTED)
            compliant =(  (supported == TRIGGERING_STANDARD__UNSUPPORTED) ? COMPLIANT__N : COMPLIANT__Y)
            self.update_standard_checks_required(standard['id'],object,CHECKING_STATUS__RESOLVED,how_resolved,compliant)
            if (compliant==COMPLIANT__N)
              msg = "Elected not to follow this standard - and dependent standards"
              puts "noted #{msg} #{standard['id']}"
              ViolationHelper.add_violation(object,violations,standard['id'],msg)
              puts object
            end
            
          end    
        end  
        # now set to resolved if compliance is simply stated in metadata signed off  
      end
    end  
    #puts "--finish adding standards checks"      
    account_for_stated_compliance(object,violations)
  end

  # uses the standards file to augment the API metadata file with the standards that SHOULD be verified for each object
  # during rules checking any problems can be logged under these entries and we can also show what checking was done
  # At the end of the run we can use this information to build a run report and also figure out what wasnt checked
  def self.update_with_standards_to_check(metadata,violations,standards)

    puts "Updating API Metadata with standards to check"
    parents = Hash.new
    for context in metadata[META_CONTEXTS]
      #     puts("adding checks for context ... #{context['context']}")  
      self.add_standards_checks_required(parents,context,"context",standards,violations)
      
      #           puts("checking context ... #{context['context']}")
      parents['context'] = context
      for version in context[META_VERSIONS]
        #puts("adding checks for version ... #{version['version']}")  
        self.add_standards_checks_required(parents,version,"version",standards,violations)
        
        
        parents['version'] = version  
        for r in version[META_RESOURCES]
          #puts("adding checks for r ... #{r['resource']}")   
          #puts r 
          if (r["resource_type"]==RESOURCE_TYPE__COLLECTION) then
            #           puts("adding checks for collectoin r ... #{r['resource']}")   
            #           puts "adding standards for resource collections!"
            self.add_standards_checks_required(parents,r,StandardsHelper::SCOPE__COLLECTION_RESOURCE,standards,violations)
          end
          if (r["resource_type"]==RESOURCE_TYPE__SINGULAR) then
            #           puts("adding checks for collectoin r ... #{r['resource']}")   
            #           puts "adding standards for resource collections!"
            self.add_standards_checks_required(parents,r,StandardsHelper::SCOPE__SINGULAR_RESOURCE,standards,violations)
          end
          #         puts("adding checks for regular r ... #{r['resource']}")   
          self.add_standards_checks_required(parents,r,StandardsHelper::SCOPE__RESOURCE,standards,violations)
          
        end
        
      end
      
    end
 
    
  end


  # there are a number of triggering StandardsHelper:: When we support these standards, other dependent standards must then be checked. Triggering standards apply to different levels in the context / version / resource 
  # hierarchy. Based on the of the triggering level of the standard (context / version / collectio_resource / singular_resource / resource)  we need to check if the scope file indicates if this standard has been attempted or not
  def self.verify_trigger_info(standards,r_scope)

    for standard in standards   
      if (standard["dependency"]==StandardsHelper::DEPENDENCY__TRIGGERING) then  
         
       if (standard["trigger_level"]==StandardsHelper::TRIGGER_LEVEL__CONTEXT) then
         
         for context in r_scope[META_CONTEXTS]
           object_property_array_has_property_with_value(context,"triggering_standards","id",standard["id"],true,"Data missing from metadata: Could not find entry stating if the triggering standard #{standard["id"]} is supported at the context level") 
         end
         
       elsif (standard["trigger_level"]==StandardsHelper::TRIGGER_LEVEL__VERSION) then
         
#       puts "version level triggering standard #{standard["id"]} #{standard["trigger_level"]}"
         
         for context in r_scope[META_CONTEXTS]
           #           puts("checking context ...")      
           for version in context[META_VERSIONS]
             object_property_array_has_property_with_value(version,"triggering_standards","id",standard["id"],true,triggering_standard_statement_missing_msg(standard["id"],"version",[context["context"],version["version"]]))
           end   
         end
         
       elsif  (standard["trigger_level"]=="collection_resource" || standard["trigger_level"]==StandardsHelper::TRIGGER_LEVEL__RESOURCE) then
         
         for context in r_scope[META_CONTEXTS]
           #           puts("checking context ... #{context['context']}")
           for version in context[META_VERSIONS]
             #           puts("checking version ... #{version['version']}")   
             for r in version[META_RESOURCES]
               #               puts("checking resource ... #{r['resource']}")  
               if (r["resource_type"]==RESOURCE_TYPE__COLLECTION && (standard["trigger_level"]==StandardsHelper::SCOPE__COLLECTION_RESOURCE)) then
                 #                puts "collection resource and trigger level cr #{r['triggering_standards']} st #{standard["id"]}"
                 object_property_array_has_property_with_value(r,"triggering_standards","id",standard["id"],true,triggering_standard_statement_missing_msg(standard["id"],"collection",[context["context"],version["version"],r["resource"]]))
               elsif(standard["trigger_level"]==StandardsHelper::TRIGGER_LEVEL__RESOURCE)
                 object_property_array_has_property_with_value(r,"triggering_standards","id",standard["id"],true,triggering_standard_statement_missing_msg(standard["id"],"resource",[context["context"],version["version"],r["resource"]]))
                 
               end
             end   
           end 
         end
         
       elsif  (standard["trigger_level"]==StandardsHelper::TRIGGER_LEVEL__SINGULAR_RESOURCE) then
         exit
       else 
         puts "Unsupported trigger_level '#{standard["trigger_level"]}' for standard #{standard["id"]}"
         exit
       end
       
      end
     

    end
  
  end
    
  # method returns msgs to display if the metadata is missing information on supported standards 
  def self.triggering_standard_statement_missing_msg(standard,object_level,name_hierarchy)
    "Data missing from metadata: Could not find entry stating if the triggering standard #{standard} is supported or not for #{object_level} #{name_hierarchy.join('>')}"
  end

  # Given the example json for object
  # { "property_a": "x",
  #    "property_b": [ { "thing" : "i"  }, {"thing" : "j"} , {"thing" : "k"} ]
  # }
  # this method would return true if called with (object,"property_b","thing","k") because the objects property array property_b has one of the array
  # entries with a proprty "thing" of value "k". 
  # if stop_on_false is true execution will stop if the method would not return true
  def self.object_property_array_has_property_with_value(object,property,array_object_property,array_object_value,stop_on_false,msg)  
    
    for array_object in object[property]
      #     puts "#{array_object[array_object_property]} V: #{array_object_value}"
      if (array_object[array_object_property]==array_object_value) then
        return true
      end     
    end
 
    OutputHelper.fatal_msg(msg) if stop_on_false 

    return false

  end  

 

end

